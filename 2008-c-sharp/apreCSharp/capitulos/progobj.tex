\section{Programação Baseada em Objetos}

\subsection{Convenções e Padrões de Nomenclatura}

\begin{frame}
    \frametitle{Recomendação da Microsoft para nomeação de variáveis}
    \begin{itemize}
            \item <1-> Evite usar underline "\_";
            \item <2-> Não crie variáveis com o mesmo nome mudando somente entre maiúsculas e minúsculas;
            \item <3-> Utilize nomes de variáveis com minúsculas;
            \item <4-> Evite utilizar todas as letras maiúsculas;
            \item <5-> Notação \emph{camelCasing}: Primeira letra de cada palavra em caixa alta, menos da primeira;
            \item <6-> Recomendações para nomeação de classes, métodos: Notação \emph{PascalCasing}: primeiro caractere de cada palavra em
            caixa alta.
    \end{itemize}
\end{frame}

\subsection{Classes}

\begin{frame}
    \frametitle{Classes}
    \begin{block}{Definição}
        Uma classe é um poderoso tipo de dado em C\#. Como estrutura, uma
        classe define os dados e o comportamento dos tipos de dados.
    \end{block}
    \texttt{\lstinputlisting[language=C, label=classe, caption={Exemplo
    de Classe em C\#}]{cods/classe.txt}}
\end{frame}

\subsection{Propriedades}

\begin{frame}
    \frametitle{Propriedades}
    \begin{block}{Definição}
        As propriedades são recursos fornecidos pelas classes para que seja
        possível alterar seus valores.
    \end{block}
    \texttt{\lstinputlisting[language=C, label=propriedades,
    caption={Exemplo de Propriedades em C\#}]{cods/propriedade.txt}}
\end{frame}

\subsection{Modificadores de visibilidade}

\begin{frame}
    \frametitle{Modificadores de visibilidade}
    C\# apresenta os seguintes modificadores de visibilidades:
    \begin{itemize}
            \item  \emph{private};
            \item  \emph{public};
            \item  \emph{protected};
            \item  \emph{internal};
    \end{itemize}
    \texttt{\lstinputlisting[language=C, label=modificadoresVis,
    caption={Exemplo de utilização dos modificadores de visibilidade
    C\#}]{cods/modificadores.txt}}
\end{frame}

\subsection{Herança}

\begin{frame}
    \frametitle{Herança}
    \begin{block}{Definição}
        A herança é um recurso utilizado para derivar classes que têm
        métodos ou atributos em comum. Sua principal vantagem é o
        reaproveitamento de código.
    \end{block}
    \texttt{\lstinputlisting[language=C, label=Heranca, caption={Exemplo
    de declaração de herança em C\#}]{cods/heranca.txt}}
\end{frame}

\begin{frame}
    \frametitle{\emph{This} e \emph{Base}}
    \begin{block}{Definição}
        As cláusulas \emph{this} e \emph{base} são referências que indicam a
        propria classe e a classe base, respectivamente.

        \emph{Classe base}: classe cuja a classe atual herda as
        propriedades e atributos.
    \end{block}
    \texttt{\lstinputlisting[language=C, label=thisBase,
    caption={Exemplo de this e base em
    C\#}]{cods/thisbase.txt}}
\end{frame}

\subsection{Declaração e Chamada de Métodos e Objetos}

\begin{frame}
    \frametitle{Declaração e Chamada de Métodos e Objetos}
    \begin{itemize}
        \item Instanciar um objeto: operador \emph{new};
        \item Acessar seus atributos e métodos: instrução ".";
    \end{itemize}
    \texttt{\lstinputlisting[language=C, label=instObjeto,
    caption={Exemplo instanciação de objeto em C\#}]{cods/instobj.txt}}
    \texttt{\lstinputlisting[language=C, label=acessoAtrMet,
    caption={Exemplo acesso a atributos e métodos em
    C\#}]{cods/acessoatrmet.txt}}
\end{frame}

\subsection{Métodos e Atributos Static}

\begin{frame}[t,allowframebreaks]
    \frametitle{Métodos e Atributos \emph{Static}}
    \begin{block}{O que é \emph{static}?}
        \emph{Static} define um método ou atributo como
        pertencentes à classe em questão e não aos objetos.
    \end{block}

    \begin{block}{Como se declara?}
        Sua declaração é feita com a palavra \emph{static} depois do
        modificador de acesso (\emph{public, private}) e antes do tipo de
        dado (\emph{int, string}).
    \end{block}

    \begin{block}{Como se acessa?}
        O seu acesso é feito pelo nome da classe e não mais pela referência
        da classe ou pelo nome do objeto.
    \end{block}

    \texttt{\lstinputlisting[language=C, label=static, caption={Exemplo
    acesso a atributos e métodos estáticos em C\#}]{cods/static.txt}}
\end{frame}

\subsection{Const e ReadOnly}

\begin{frame}[t,allowframebreaks]
    \frametitle{Const e ReadOnly}
    \begin{block}{Definição}
        São operadores utilizados para a criação de constantes, cujos os
        valores não poderão ser alterados durante a execução do programa.
    \end{block}

    Algumas diferenças entre os operadores:

    \begin{itemize}
        \item \emph{const}:
        \begin{itemize}
            \item Não pode ser estático (\emph{static});
            \item O valor é setado em tempo de compilação;
            \item É inicializado somente na compilação.
        \end{itemize}
        \item \emph{readonly}:
        \begin{itemize}
            \item Pode ser estático (\emph{static});
            \item O valor é setado em tempo de execução;
            \item Pode ser inicializado na declaração ou na codificação
            do construtor.
        \end{itemize}
    \end{itemize}
\end{frame}

\subsection{Classes e Métodos Abstratos}

\begin{frame}[t,allowframebreaks]
    \frametitle{Classes e Métodos Abstratos}
    \begin{block}{Definição}
        A classe abstrata é um tipo de classe que somente pode ser herdada e
        não instanciada.
    \end{block}
    \begin{block}{Para que é utilizada?}
        É utilizada para definir as funcionalidades que serão implementas em suas subclasses.
    \end{block}
    \texttt{\lstinputlisting[language=C, label=abstract,
    caption={Exemplo de implementação de uma classe abstrata em
    C\#}]{cods/abstract.txt}}
\end{frame}

\subsection{Interfaces}

\begin{frame}[t,allowframebreaks]
    \frametitle{Interfaces}
    \begin{block}{Definição}
        Uma interface define as operações que um objeto será
        obrigado a implementar.
    \end{block}
    \begin{itemize}
        \item Nunca contém implementação;
        \item Não permite construtores;
        \item Deve-se criar uma classe ou estrutura e herdar da
        interface;
        \item Deve-se implementar todos os métodos da interface.
    \end{itemize}
    \texttt{\lstinputlisting[language=C, label=interface,
    caption={Exemplo de implementação de uma interface em
    C\#}]{cods/interface.txt}}
    Note que, para se sobrescrever um método da interface utilizamos
    \emph{$<$Interface$>$.$<$Metodo$>$}. Código \ref{interface}, Linha 5.
    A declaração de uma instância de uma interface é feita de forma
    diferente da declaração de um objeto normal, aqui temos: Interface
    $<$var$>$ = new $<$ClasseQueImplementaAInterface$>$(); Código
    \ref{interface}, Linha 15.
\end{frame}

\subsection{Métodos Virtuais}

\begin{frame}
    \frametitle{Métodos Virtuais}
    \begin{itemize}
        \item Usado para permitir que um método seja sobrescrito;
        \item Podem possuir corpo;
        \item Caso um método não seja declarado como \emph{virtual}
        ou \emph{abstract}, não poderá ser sobrescrito;
    \end{itemize}
\end{frame}

\subsection{Classes e Métodos Sealed - Finais}

\begin{frame}
    \frametitle{Classes e Métodos Sealed - Finais}
    \begin{block}{Definição}
        Uma classe selada é utilizada para restringir características da
        herança do objeto.
    \end{block}
    \begin{itemize}
        \item Os métodos declarados como \emph{sealed} também não poderão ser sobrescritos;
    \end{itemize}
    \texttt{\lstinputlisting[language=C, label=seled, caption={Exemplo
    de implementação de uma classe sealed em C\#}]{cods/seled.txt}}
\end{frame}
